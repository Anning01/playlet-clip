"""Video and narration segment data structures."""

from pathlib import Path
from typing import Literal

from pydantic import BaseModel, Field


class VideoSegment(BaseModel):
    """A video segment to be processed."""

    start_time: float = Field(ge=0, description="Start time in seconds")
    end_time: float = Field(ge=0, description="End time in seconds")
    source_path: Path | None = Field(default=None, description="Source video path")
    output_path: Path | None = Field(default=None, description="Output video path")

    @property
    def duration(self) -> float:
        """Duration in seconds."""
        return self.end_time - self.start_time


class NarrationSegment(BaseModel):
    """A narration segment generated by LLM."""

    type: Literal["解说", "video"] = Field(description="Segment type")
    content: str | None = Field(default=None, description="Narration text (for 解说 type)")
    start_time: float = Field(ge=0, description="Start time in seconds")
    end_time: float = Field(ge=0, description="End time in seconds")

    # Generated assets
    audio_path: Path | None = Field(default=None, description="Generated audio path")
    subtitle_path: Path | None = Field(default=None, description="Generated subtitle path")
    video_path: Path | None = Field(default=None, description="Processed video path")

    @property
    def duration(self) -> float:
        """Duration in seconds."""
        return self.end_time - self.start_time

    @property
    def is_narration(self) -> bool:
        """Check if this is a narration segment."""
        return self.type == "解说"

    @property
    def time_str(self) -> str:
        """Get time range as SRT format string."""
        return f"{self._seconds_to_srt(self.start_time)} --> {self._seconds_to_srt(self.end_time)}"

    @staticmethod
    def _seconds_to_srt(seconds: float) -> str:
        """Convert seconds to SRT time format."""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        millis = int((seconds % 1) * 1000)
        return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"

    @classmethod
    def from_llm_response(cls, data: dict) -> "NarrationSegment":
        """Create from LLM response dict."""
        # Parse time string: "HH:MM:SS,mmm --> HH:MM:SS,mmm"
        time_str = data.get("time", "")
        start_time, end_time = cls._parse_time_range(time_str)

        return cls(
            type=data.get("type", "video"),
            content=data.get("content"),
            start_time=start_time,
            end_time=end_time,
        )

    @staticmethod
    def _parse_time_range(time_str: str) -> tuple[float, float]:
        """Parse time range string to start and end seconds."""
        parts = time_str.split(" --> ")
        if len(parts) != 2:
            return 0.0, 0.0

        def parse_time(t: str) -> float:
            t = t.strip().replace(",", ".")
            parts = t.split(":")
            if len(parts) != 3:
                return 0.0
            hours = int(parts[0])
            minutes = int(parts[1])
            seconds = float(parts[2])
            return hours * 3600 + minutes * 60 + seconds

        return parse_time(parts[0]), parse_time(parts[1])


class TTSResult(BaseModel):
    """Result from TTS synthesis."""

    audio_path: Path = Field(description="Generated audio file path")
    subtitle_path: Path | None = Field(default=None, description="Generated subtitle file path")
    duration: float = Field(ge=0, description="Audio duration in seconds")
    sample_rate: int = Field(default=22050, description="Audio sample rate")
